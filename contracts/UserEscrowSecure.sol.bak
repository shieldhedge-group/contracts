// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "./interfaces/IEscrowFactory.sol";
import "./interfaces/IWhitelistManager.sol";

/* ========== SECURE USER ESCROW (Multi-Signature + Bot Safety) ========== */
contract UserEscrowSecure is ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;
    using ECDSA for bytes32;

    /* ========== STATE VARIABLES ========== */
    address public immutable factory;
    address public owner;
    address public pendingOwner;
    uint256 public transferDeadline;
    uint256 public constant OWNERSHIP_DELAY = 7 days;

    // Multi-signature system
    mapping(address => bool) public isApproverMap;
    address[] public approvers;
    uint256 public threshold;
    uint256 public nonce;

    // SECURE Bot automation with proper authorization
    address public escrowManager; // Authorized EscrowManager
    mapping(address => bool) public authorizedBots; // Multi-bot support
    mapping(address => uint256) public botOperationLimits; // Per-bot ETH limits
    mapping(address => uint256) public botDailySpent; // Track daily spending
    mapping(address => uint256) public botLastResetDay; // Daily limit reset

    // Pre-approved operation types (whitelist approach)
    mapping(bytes4 => bool) public approvedSelectors; // Function selectors
    mapping(address => mapping(bytes4 => bool)) public botAllowedOperations; // Bot-specific operations

    uint256 public constant MAX_BOT_VALUE_PER_TX = 0.1 ether; // Max per transaction
    uint256 public constant BOT_DAILY_LIMIT = 1 ether; // Max per day
    bool public botSystemEnabled = true;

    // Balance tracking for LP tokens
    mapping(address => uint256) public lpBalance0;
    mapping(address => uint256) public lpBalance1;

    address public usdcAddress;
    mapping(address => bool) public authorizedDepositors;

    /* ========== EVENTS ========== */
    event DepositedETH(address indexed from, uint256 amount);
    event DepositedToken(address indexed token, address indexed from, uint256 amount);
    event WithdrawnETH(address indexed to, uint256 amount);
    event WithdrawnToken(address indexed token, address indexed to, uint256 amount);
    event ExecutedCall(address indexed target, uint256 value, bytes data, bytes result);
    event ExecutedWithSignatures(address indexed target, uint256 value, bytes data, address[] signers);

    // Security events
    event BotOperationExecuted(address indexed bot, address indexed target, bytes4 selector, uint256 value);
    event BotOperationBlocked(address indexed bot, address indexed target, string reason);
    event BotAuthorized(address indexed bot, bool authorized, uint256 dailyLimit);
    event OperationPreApproved(bytes4 indexed selector, bool approved);

    /* ========== MODIFIERS ========== */
    modifier onlyOwner() {
        require(msg.sender == owner, "UserEscrow: caller is not the owner");
        _;
    }

    modifier notZero(address addr) {
        require(addr != address(0), "UserEscrow: zero address");
        _;
    }

    modifier onlyWhitelisted(address target) {
        require(
            IWhitelistManager(IEscrowFactory(factory).whitelistManager()).isWhitelisted(target),
            "UserEscrow: target not whitelisted"
        );
        _;
    }

    modifier onlyAuthorizedDepositor() {
        require(
            msg.sender == owner ||
            isApproverMap[msg.sender] ||
            authorizedDepositors[msg.sender],
            "UserEscrow: unauthorized depositor"
        );
        _;
    }

    /**
     * @dev SECURE: Bot authorization with strict limits and operation whitelist
     */
    modifier secureBot(address target, uint256 value, bytes calldata data) {
        require(botSystemEnabled, "UserEscrow: bot system disabled");
        require(authorizedBots[msg.sender], "UserEscrow: unauthorized bot");
        require(value <= MAX_BOT_VALUE_PER_TX, "UserEscrow: exceeds per-transaction limit");

        // Daily spending limit check
        uint256 currentDay = block.timestamp / 1 days;
        if (botLastResetDay[msg.sender] < currentDay) {
            botDailySpent[msg.sender] = 0;
            botLastResetDay[msg.sender] = currentDay;
        }

        require(
            botDailySpent[msg.sender] + value <= botOperationLimits[msg.sender],
            "UserEscrow: exceeds daily bot limit"
        );

        // Function selector validation
        bytes4 selector = bytes4(data[:4]);
        require(
            approvedSelectors[selector] && botAllowedOperations[msg.sender][selector],
            "UserEscrow: operation not approved for this bot"
        );

        botDailySpent[msg.sender] += value;
        _;
    }

    /* ========== CONSTRUCTOR ========== */
    constructor(
        address _factory,
        address _owner,
        address[] memory _approvers,
        uint256 _threshold
    ) {
        require(_factory != address(0), "UserEscrow: factory cannot be zero");
        require(_owner != address(0), "UserEscrow: owner cannot be zero");
        require(_approvers.length > 0, "UserEscrow: need at least one approver");
        require(_threshold > 0 && _threshold <= _approvers.length, "UserEscrow: invalid threshold");

        factory = _factory;
        owner = _owner;
        threshold = _threshold;

        for (uint256 i = 0; i < _approvers.length; i++) {
            address approver = _approvers[i];
            require(approver != address(0), "UserEscrow: approver cannot be zero");
            require(!isApproverMap[approver], "UserEscrow: duplicate approver");

            isApproverMap[approver] = true;
            approvers.push(approver);
        }

        usdcAddress = IEscrowFactory(_factory).getUSDCAddress();

        // Pre-approve common DeFi operations (ERC20 + LP operations only)
        _preApproveSecureOperations();
    }

    /* ========== CORE EXECUTION FUNCTIONS ========== */

    /**
     * @notice Standard execution with full signature validation (unchanged)
     */
    function executeWithSignatures(
        address target,
        uint256 value,
        bytes calldata data,
        bytes[] calldata signatures,
        uint256 deadline
    ) external payable nonReentrant notZero(target) onlyWhitelisted(target) {
        require(signatures.length >= threshold, "UserEscrow: insufficient signatures");
        require(block.timestamp <= deadline, "UserEscrow: signature expired");
        require(value <= address(this).balance, "UserEscrow: insufficient balance");

        // Compute message hash with secure replay protection and deadline
        bytes32 rawHash = keccak256(
            abi.encode(
                address(this),
                block.chainid,
                target,
                value,
                keccak256(data),
                nonce,
                deadline
            )
        );
        bytes32 messageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", rawHash));

        // Verify signatures
        address[] memory signers = new address[](signatures.length);
        uint256 validSigners = 0;
        for (uint256 i = 0; i < signatures.length; i++) {
            address signer = ECDSA.recover(messageHash, signatures[i]);
            require(isApproverMap[signer], "UserEscrow: invalid signer");

            for (uint256 j = 0; j < validSigners; j++) {
                require(signers[j] != signer, "UserEscrow: duplicate signer");
            }
            signers[validSigners] = signer;
            validSigners++;
        }
        require(validSigners >= threshold, "UserEscrow: insufficient valid signatures");

        // Execute the call
        (bool ok, bytes memory result) = target.call{value: value}(data);
        require(ok, "UserEscrow: execution failed");

        nonce++;
        emit ExecutedWithSignatures(target, value, data, signers);
    }

    /**
     * @notice SECURE bot execution with strict validation and limits
     * @dev This requires owner pre-approval of bot and operations
     */
    function executeSecureBotOperation(
        address target,
        uint256 value,
        bytes calldata data
    )
        external
        payable
        nonReentrant
        notZero(target)
        onlyWhitelisted(target)
        secureBot(target, value, data)
        returns (bytes memory)
    {
        require(msg.value == value, "UserEscrow: msg.value mismatch");
        require(value <= address(this).balance, "UserEscrow: insufficient balance");

        // Additional safety: Check if this is a recognized DeFi operation
        bytes4 selector = bytes4(data[:4]);
        require(_isSecureDeFiOperation(target, selector), "UserEscrow: not a secure DeFi operation");

        // Execute with additional monitoring
        (bool ok, bytes memory result) = target.call{value: value}(data);

        if (!ok) {
            emit BotOperationBlocked(msg.sender, target, "execution failed");
            revert("UserEscrow: secure bot operation failed");
        }

        nonce++;
        emit BotOperationExecuted(msg.sender, target, selector, value);
        return result;
    }

    /**
     * @notice Owner-only function to authorize bots with specific limits
     */
    function authorizeBotWithLimits(
        address bot,
        bool authorized,
        uint256 dailyLimit,
        bytes4[] calldata allowedOperations
    ) external onlyOwner notZero(bot) {
        require(dailyLimit <= BOT_DAILY_LIMIT, "UserEscrow: exceeds maximum daily limit");

        authorizedBots[bot] = authorized;
        botOperationLimits[bot] = dailyLimit;

        // Set allowed operations for this bot
        for (uint256 i = 0; i < allowedOperations.length; i++) {
            botAllowedOperations[bot][allowedOperations[i]] = authorized;
        }

        emit BotAuthorized(bot, authorized, dailyLimit);
    }

    /**
     * @notice Owner-only function to pre-approve operation types
     */
    function approveOperationType(bytes4 selector, bool approved) external onlyOwner {
        approvedSelectors[selector] = approved;
        emit OperationPreApproved(selector, approved);
    }

    /**
     * @notice Set EscrowManager with proper authorization
     */
    function setEscrowManager(address _escrowManager) external onlyOwner {
        escrowManager = _escrowManager;
        if (_escrowManager != address(0)) {
            authorizedDepositors[_escrowManager] = true;
            // Auto-authorize common DeFi operations for EscrowManager
            _authorizeManagerOperations(_escrowManager);
        }
    }

    /* ========== INTERNAL SECURITY FUNCTIONS ========== */

    /**
     * @dev Pre-approve only secure, common DeFi operations
     */
    function _preApproveSecureOperations() internal {
        // ERC20 operations
        approvedSelectors[0xa9059cbb] = true; // transfer(address,uint256)
        approvedSelectors[0x095ea7b3] = true; // approve(address,uint256)

        // Common LP operations (Uniswap V3 style)
        approvedSelectors[0xb5007d1f] = true; // mint(...) - LP creation
        approvedSelectors[0xfc6f7865] = true; // collect(...) - fee collection
        approvedSelectors[0x0c49ccbe] = true; // decreaseLiquidity(...) - LP removal

        // Swap operations (limited)
        approvedSelectors[0xac9650d8] = true; // multicall(bytes[]) - batch operations
    }

    /**
     * @dev Check if operation is a recognized secure DeFi operation
     */
    function _isSecureDeFiOperation(address target, bytes4 selector) internal view returns (bool) {
        // Additional validation for known DeFi contracts
        // This could check against a registry of known secure contracts
        return approvedSelectors[selector];
    }

    /**
     * @dev Auto-authorize EscrowManager for common operations
     */
    function _authorizeManagerOperations(address manager) internal {
        bytes4[] memory commonOps = new bytes4[](6);
        commonOps[0] = 0xa9059cbb; // transfer
        commonOps[1] = 0x095ea7b3; // approve
        commonOps[2] = 0xb5007d1f; // mint
        commonOps[3] = 0xfc6f7865; // collect
        commonOps[4] = 0x0c49ccbe; // decreaseLiquidity
        commonOps[5] = 0xac9650d8; // multicall

        authorizedBots[manager] = true;
        botOperationLimits[manager] = BOT_DAILY_LIMIT; // Full daily limit for manager

        for (uint256 i = 0; i < commonOps.length; i++) {
            botAllowedOperations[manager][commonOps[i]] = true;
        }
    }

    /* ========== EMERGENCY FUNCTIONS ========== */

    /**
     * @notice Emergency: Disable bot system
     */
    function emergencyDisableBots() external onlyOwner {
        botSystemEnabled = false;
    }

    /**
     * @notice Emergency: Revoke all bot permissions
     */
    function emergencyRevokeAllBots() external onlyOwner {
        // This would need to iterate through known bots
        // In practice, you'd maintain a list of authorized bots
        botSystemEnabled = false;
    }

    /* ========== VIEW FUNCTIONS ========== */

    function getBotStatus(address bot) external view returns (
        bool authorized,
        uint256 dailyLimit,
        uint256 dailySpent,
        uint256 remainingToday
    ) {
        authorized = authorizedBots[bot];
        dailyLimit = botOperationLimits[bot];

        uint256 currentDay = block.timestamp / 1 days;
        if (botLastResetDay[bot] < currentDay) {
            dailySpent = 0;
        } else {
            dailySpent = botDailySpent[bot];
        }

        remainingToday = dailyLimit > dailySpent ? dailyLimit - dailySpent : 0;
    }

    function isOperationAllowed(address bot, bytes4 selector) external view returns (bool) {
        return authorizedBots[bot] &&
               approvedSelectors[selector] &&
               botAllowedOperations[bot][selector];
    }

    /* ========== STANDARD FUNCTIONS (unchanged) ========== */

    receive() external payable onlyAuthorizedDepositor {
        emit DepositedETH(msg.sender, msg.value);
    }

    function getETHBalance() external view returns (uint256) {
        return address(this).balance;
    }

    function getTokenBalance(address token) external view returns (uint256) {
        return IERC20(token).balanceOf(address(this));
    }

    function getApprovers() external view returns (address[] memory) {
        return approvers;
    }

    // ... (other standard functions remain the same)
}